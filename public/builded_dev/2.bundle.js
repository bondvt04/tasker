webpackJsonp([2],{174:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(161), RootInstanceProvider = __webpack_require__(159), ReactMount = __webpack_require__(69), React = __webpack_require__(3); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Router = (function () {\n    function Router(options) {\n        _classCallCheck(this, Router);\n    }\n\n    _createClass(Router, [{\n        key: "init",\n        value: function init(routerEngine) {\n            var self = this;\n            var promise = new Promise(function (resolve, reject) {\n\n                self._router = routerEngine;\n                console.log(">>> router.init()");\n\n                if (true) {\n                    resolve(self);\n                } else {\n                    reject(new Error("Error while router.init"));\n                }\n            });\n\n            return promise;\n        }\n    }]);\n\n    return Router;\n})();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n//"../../../lib/router.js/router-amd.js"\n__webpack_require__(175)], __WEBPACK_AMD_DEFINE_RESULT__ = function (RADRouter) {\n    var instance;\n\n    return (function () {\n        return instance = instance || new Router(RADRouter).init();\n    })();\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*define([\n    //"dojo/_base/declare",\n    //"dojo/router",\n    //"dojo/topic",\n    //"dojo/hash"\n], function(router, topic, hash){\n    var Router = function() {\n        console.log("> Router");\n    }\n\n    return Router;\n\n    /*var routerClass = declare(null, {\n\n        _currentHash : null,\n\n        _currentRoute : null,\n\n        _routes : {},\n\n        addRoutes : function(routes) {\n            if(routes) {\n                for (var routeName in routes) {\n                    this._routes[routeName] = routes[routeName];\n                }\n            }\n\n            // check only new routes\n            this.checkRoutesAndRunIfMatch(routes);\n        },\n\n        checkRoutesAndRunIfMatch : function(routes) {\n            var routesToCheck = routes || this._routes;\n\n            this._currentHash = hash();\n\n            if(!this._currentHash) {\n                hash("/");\n                this._currentHash = "/"\n            }\n\n            if(routesToCheck) {\n                for(var routeName in routesToCheck) {\n                    if(this._currentHash === routeName) {\n                        this._currentRoute = {\n                            name: routeName,\n                            callback: this._routes[routeName].callback,\n                            context: this._routes[routeName].context\n                        };\n\n                        // run callback\n                        //this._currentRoute.callback();\n                        this._currentRoute.callback.apply(this._currentRoute.context);\n\n                    }\n                }\n            }\n        },\n\n        init : function() {\n            var self = this;\n            var promise = new Promise(function(resolve, reject) {\n\n                //router.register("/user/:id", function (event) {\n                //    console.log("Hash change", event.params.id);\n                //});\n\n                //console.log(hash());\n\n                topic.subscribe("/dojo/hashchange", function(changedHash){\n                    self.checkRoutesAndRunIfMatch();\n                });\n\n                self.checkRoutesAndRunIfMatch();\n\n                //router.go("hash");\n                //hash("someURL");\n\n                if (true) {\n                    resolve(self);\n                } else {\n                    reject(new Error("Error while router.init"));\n                }\n            });\n\n            return promise;\n        }\n    });\n\n    return routerClass;\n});*/\n\n//this.model = options.model;\n\n/* REACT HOT LOADER */ }).call(this); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(169), foundReactClasses = false; if (makeExportsHot(module, __webpack_require__(3))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "index.js" + ": " + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/services/router/index.js\n ** module id = 174\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./src/services/router/index.js?')},175:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require, exports, module);\n  } else {\n    root.Router = factory();\n  }\n}(this, function(require, exports, module) {\n\nvar _ALLOWED_MODES = ['node', 'hash', 'history'];\nvar _DEFAULT_OPTIONS = {mode: 'node', keys: true, root: '/', rerouting: true};\n\n// parse regular expression\nvar _OPTIONAL_PARAM = /\\((.*?)\\)/g;\nvar _NAMED_PARAM = /(\\(\\?)?:\\w+/g;\nvar _SPLAT_PARAM = /\\*\\w+/g;\nvar _ESCAPE_REG_EXP = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\nvar _DEFAULT_ROUTE = /.*/;\n\nvar _FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar _STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction _getRouteKeys(string) {\n    var keys = string.match(/:([^\\/]+)/g);\n    for (var i = 0, l = keys ? keys.length : 0; i < l; i += 1) {\n        keys[i] = keys[i].replace(/[:\\(\\)]/g, '');\n    }\n    return keys;\n}\n\nfunction _routeToRegExp(route) {\n    route = route.replace(_ESCAPE_REG_EXP, '\\\\$&')\n        .replace(_OPTIONAL_PARAM, '(?:$1)?')\n        .replace(_NAMED_PARAM, function (match, optional) {\n            return optional ? match : '([^/?]+)';\n        })\n        .replace(_SPLAT_PARAM, '([^?]*)');\n\n    return new RegExp('^' + route + '(?:\\\\?*([^/]*))');\n}\n\nfunction _clearSlashes(path) {\n    return path.toString().replace(/\\/$/, '').replace(/^\\//, '');\n}\n\nfunction _extractParameters(route, fragment) {\n    var params = route.exec(fragment).slice(1);\n\n    return params.map(function (param, i) {\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n    });\n}\n\nfunction _parseQuery(qstr) {\n    var query, params, pair;\n    if (typeof qstr === 'string') {\n        query = {};\n        params = qstr.split('&');\n        for (var i = 0; params, i < params.length; i++) {\n            pair = params[i].split('=');\n            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n    return query;\n}\n\nfunction _prepareArguments(parameters, keys) {\n    var wrapper = {}, lastIndex = parameters.length - 1, query = parameters[lastIndex];\n\n    if (keys && keys.length > 0) {\n        for (var i = 0; i < keys.length; i += 1) {\n            wrapper[keys[i]] = parameters[i];\n        }\n        if (parameters[i]) {\n            wrapper.query = _parseQuery(parameters[i]);\n        }\n        parameters = [wrapper];\n    } else if (query && query.indexOf('=') > -1) {\n        parameters[lastIndex] = _parseQuery(query);\n    }\n\n    return parameters;\n}\n\nfunction _asyncDetect(fn) {\n    var result = null, args;\n\n    args = fn.toString().replace(_STRIP_COMMENTS, '').match(_FN_ARGS)[1];\n    if (args && args.length > 0) {\n        args.split(',').forEach(function (item, index) {\n            if (item.trim() === 'complete') {\n                result = index;\n            }\n        });\n    }\n\n    return result;\n}\n\nfunction RoutingLevel() {\n    this._routes = [];\n    this._options = JSON.parse(JSON.stringify(_DEFAULT_OPTIONS));\n}\n\nRoutingLevel.prototype.add = function (path, callback, options) {\n    var keys, re;\n\n    if (typeof path == 'function') {\n        options = callback;\n        callback = path;\n        re = _DEFAULT_ROUTE;\n    } else {\n        keys = _getRouteKeys(path);\n        re = _routeToRegExp(path);\n    }\n\n    this._routes.push({\n        async: (options && typeof options.async === 'number') ? options.async : _asyncDetect(callback),\n        path: re,\n        callback: callback,\n        keys: keys,\n        alias: (options && options.alias) ? options.alias : path,\n        facade: null\n    });\n\n    return this;\n};\n\nRoutingLevel.prototype.remove = function (alias) {\n    for (var i = this._routes.length - 1, r; i > -1, r = this._routes[i]; i -= 1) {\n        if (alias === r.alias || alias === r.callback || alias.toString() === r.path.toString()) {\n            this._routes.splice(i, 1);\n        } else if (r._routes.length > 0) {\n            for (var j = r._routes.length - 1; j > -1; j -= 1) {\n                r._routes[j].remove(alias);\n            }\n        }\n    }\n\n    return this;\n};\n\nRoutingLevel.prototype.check = function (fragment, array, lastURL) {\n    var match, node, route, params, should;\n\n    for (var i = 0; i < this._routes.length, route = this._routes[i]; i++) {\n        match = fragment.match(route.path);\n        if (match) {\n            params = _extractParameters(route.path, fragment);\n            keys = this._options.keys ? route.keys : null;\n            params = _prepareArguments(params, keys);\n            should = (fragment.slice(0, match[0].length) !== lastURL.slice(0, match[0].length));\n\n            node = {\n                callback: route.callback,\n                params: params,\n                routes: [],\n                async: route.async,\n                rootRerouting: this._options.rerouting || should\n            };\n            array.push(node);\n\n            if (route.facade) {\n                fragment = fragment.slice(match[0].length, fragment.length);\n                lastURL = lastURL.slice(match[0].length, lastURL.length);\n                route.facade.check(fragment, node.routes, lastURL);\n            }\n            break;\n        }\n    }\n\n    return array;\n};\n\nRoutingLevel.prototype.drop = function () {\n    this._routes = [];\n    this.config(_DEFAULT_OPTIONS);\n\n    return this;\n};\n\nRoutingLevel.prototype.config = function (options) {\n    if (typeof options === 'object') {\n        this._options.keys = (typeof options.keys === 'boolean') ? options.keys : this._options.keys;\n        this._options.mode = (_ALLOWED_MODES.indexOf(options.mode) !== -1) ? options.mode : this._options.mode;\n        this._options.root = options.root ? '/' + _clearSlashes(options.root) + '/' : this._options.root;\n        this._options.rerouting = (typeof options.rerouting === 'boolean') ? options.rerouting : this._options.rerouting;\n    }\n\n    return this;\n};\n\nRoutingLevel.prototype.to = function (alias) {\n    var subrouter, route;\n    for (var i = 0; i < this._routes.length, route = this._routes[i]; i += 1) {\n        if (alias === route.alias) {\n            subrouter = route.facade;\n            if (!subrouter) {\n                route.facade = subrouter = (new RoutingLevel()).config(this._options);\n            }\n        }\n    }\n\n    return subrouter;\n};\n\nvar Router = (function (facade) {\n    var router = {}, lastURL = '', rollback = false;\n\n    function applyNested(routes) {\n        return function (param) {\n            if (param === false) {\n                rollback = true;\n                router.navigate(lastURL);\n            } else if (typeof param === 'string') {\n                router.route(param);\n            } else if (routes && routes.length)\n                apply(routes);\n        }\n    }\n\n    function apply(routes) {\n        var falseToReject;\n\n        if (routes)\n            for (var i = 0, route; i < routes.length, route = routes[i]; i += 1) {\n                if (typeof route.async === 'number') {\n                    route.params.splice(route.async, 0, applyNested(route.routes));\n                }\n                if (route.rootRerouting) {\n                    falseToReject = route.callback.apply(null, route.params);\n                }\n                if (typeof route.async !== 'number') {\n                    applyNested(route.routes)(falseToReject);\n                }\n            }\n    }\n\n    router.drop = function () {\n        lastURL = '';\n        return facade.drop();\n    };\n\n    router.listen = function () {\n        var self = this, current = this.getCurrent();\n\n        clearInterval(this._interval);\n        this._interval = setInterval(function () {\n            var location = router.getCurrent();\n            if (current !== location) {\n                current = location;\n                self.check(self.getCurrent());\n            }\n\n        }, 50);\n\n        window.onpopstate = function (e) {\n            if (e.state !== null && e.state !== undefined) {\n                clearInterval(self._interval);\n                self.check(self.getCurrent());\n            }\n        };\n    };\n\n    router.check = function (path) {\n        apply(facade.check(path, [], lastURL));\n        return facade;\n    };\n\n    router.navigate = function (path) {\n        var mode = facade._options.mode;\n        switch (mode) {\n            case 'history':\n                history.pushState(null, null, root + _clearSlashes(path));\n                break;\n            case 'hash':\n                window.location.href.match(/#(.*)$/);\n                window.location.href = window.location.href.replace(/#(.*)$/, '') + '#' + path;\n                break;\n            case 'node':\n                lastURL = path;\n                break;\n        }\n        return facade;\n    };\n\n    router.route = function (path) {\n        if (facade._options.mode === 'node')\n            this.check(path);\n        if (!rollback)\n            this.navigate(path);\n        rollback = false;\n\n        return facade;\n    };\n\n    router.config = function (options) {\n        return facade.config(options);\n    };\n\n    router.to = function (alias) {\n        return facade.to(alias);\n    };\n\n    router.add = function (path, callback, alias) {\n        return facade.add(path, callback, alias);\n    };\n\n    router.remove = function (alias) {\n        return facade.remove(alias);\n    };\n\n    router.getCurrent = function () {\n        var mode = facade._options.mode, root = facade._options.root, fragment = lastURL;\n        if (mode === 'history') {\n            fragment = _clearSlashes(decodeURI(location.pathname + location.search));\n            fragment = fragment.replace(/\\?(.*)$/, '');\n            fragment = root !== '/' ? fragment.replace(root, '') : fragment;\n            fragment = _clearSlashes(fragment);\n        } else if (mode === 'hash') {\n            var match = window.location.href.match(/#(.*)$/);\n            fragment = match ? match[1] : '';\n            fragment = _clearSlashes(fragment);\n        }\n\n        return fragment;\n    };\n\n    return router;\n\n})(new RoutingLevel());\nreturn Router;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/rad-router/bin/router.js\n ** module id = 175\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./lib/rad-router/bin/router.js?")}});