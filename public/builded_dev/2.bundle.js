webpackJsonp([2],{173:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(161), RootInstanceProvider = __webpack_require__(159), ReactMount = __webpack_require__(69), React = __webpack_require__(3); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Router = (function () {\n    function Router(options) {\n        _classCallCheck(this, Router);\n    }\n\n    _createClass(Router, [{\n        key: "init",\n        value: function init() {\n            var self = this;\n            var promise = new Promise(function (resolve, reject) {\n\n                console.log(">>> router.init()");\n\n                if (true) {\n                    resolve(self);\n                } else {\n                    reject(new Error("Error while router.init"));\n                }\n            });\n\n            return promise;\n        }\n    }]);\n\n    return Router;\n})();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(174)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Routerrr) {\n    //console.log(Routerrr, Router);\n    //var lol = new Routerrr();\n    var router = new Router();\n    return router;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*define([\n    //"dojo/_base/declare",\n    //"dojo/router",\n    //"dojo/topic",\n    //"dojo/hash"\n], function(router, topic, hash){\n    var Router = function() {\n        console.log("> Router");\n    }\n\n    return Router;\n\n    /*var routerClass = declare(null, {\n\n        _currentHash : null,\n\n        _currentRoute : null,\n\n        _routes : {},\n\n        addRoutes : function(routes) {\n            if(routes) {\n                for (var routeName in routes) {\n                    this._routes[routeName] = routes[routeName];\n                }\n            }\n\n            // check only new routes\n            this.checkRoutesAndRunIfMatch(routes);\n        },\n\n        checkRoutesAndRunIfMatch : function(routes) {\n            var routesToCheck = routes || this._routes;\n\n            this._currentHash = hash();\n\n            if(!this._currentHash) {\n                hash("/");\n                this._currentHash = "/"\n            }\n\n            if(routesToCheck) {\n                for(var routeName in routesToCheck) {\n                    if(this._currentHash === routeName) {\n                        this._currentRoute = {\n                            name: routeName,\n                            callback: this._routes[routeName].callback,\n                            context: this._routes[routeName].context\n                        };\n\n                        // run callback\n                        //this._currentRoute.callback();\n                        this._currentRoute.callback.apply(this._currentRoute.context);\n\n                    }\n                }\n            }\n        },\n\n        init : function() {\n            var self = this;\n            var promise = new Promise(function(resolve, reject) {\n\n                //router.register("/user/:id", function (event) {\n                //    console.log("Hash change", event.params.id);\n                //});\n\n                //console.log(hash());\n\n                topic.subscribe("/dojo/hashchange", function(changedHash){\n                    self.checkRoutesAndRunIfMatch();\n                });\n\n                self.checkRoutesAndRunIfMatch();\n\n                //router.go("hash");\n                //hash("someURL");\n\n                if (true) {\n                    resolve(self);\n                } else {\n                    reject(new Error("Error while router.init"));\n                }\n            });\n\n            return promise;\n        }\n    });\n\n    return routerClass;\n});*/\n\n//this.model = options.model;\n//this.template = options.template;\n\n/* REACT HOT LOADER */ }).call(this); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(169), foundReactClasses = false; if (makeExportsHot(module, __webpack_require__(3))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "index.js" + ": " + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/services/router/index.js\n ** module id = 173\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./src/services/router/index.js?')},174:function(module,exports){eval('(function(__exports__, __dependency1__, __dependency2__) {\n    "use strict";\n    /**\n     @private\n\n     This file references several internal structures:\n\n     ## `RecognizedHandler`\n\n     * `{String} handler`: A handler name\n     * `{Object} params`: A hash of recognized parameters\n\n     ## `HandlerInfo`\n\n     * `{Boolean} isDynamic`: whether a handler has any dynamic segments\n     * `{String} name`: the name of a handler\n     * `{Object} handler`: a handler object\n     * `{Object} context`: the active context for the handler\n     */\n\n    var RouteRecognizer = __dependency1__;\n    var RSVP = __dependency2__;\n\n    var slice = Array.prototype.slice;\n\n\n\n    /**\n     @private\n\n     A Transition is a thennable (a promise-like object) that represents\n     an attempt to transition to another route. It can be aborted, either\n     explicitly via `abort` or by attempting another transition while a\n     previous one is still underway. An aborted transition can also\n     be `retry()`d later.\n     */\n\n    function Transition(router, promise) {\n        this.router = router;\n        this.promise = promise;\n        this.data = {};\n        this.resolvedModels = {};\n        this.providedModels = {};\n        this.providedModelsArray = [];\n        this.sequence = ++Transition.currentSequence;\n        this.params = {};\n    }\n\n    Transition.currentSequence = 0;\n\n    Transition.prototype = {\n        targetName: null,\n        urlMethod: \'update\',\n        providedModels: null,\n        resolvedModels: null,\n        params: null,\n        pivotHandler: null,\n        resolveIndex: 0,\n        handlerInfos: null,\n\n        isActive: true,\n\n        /**\n         The Transition\'s internal promise. Calling `.then` on this property\n         is that same as calling `.then` on the Transition object itself, but\n         this property is exposed for when you want to pass around a\n         Transition\'s promise, but not the Transition object itself, since\n         Transition object can be externally `abort`ed, while the promise\n         cannot.\n         */\n        promise: null,\n\n        /**\n         Custom state can be stored on a Transition\'s `data` object.\n         This can be useful for decorating a Transition within an earlier\n         hook and shared with a later hook. Properties set on `data` will\n         be copied to new transitions generated by calling `retry` on this\n         transition.\n         */\n        data: null,\n\n        /**\n         A standard promise hook that resolves if the transition\n         succeeds and rejects if it fails/redirects/aborts.\n\n         Forwards to the internal `promise` property which you can\n         use in situations where you want to pass around a thennable,\n         but not the Transition itself.\n\n         @param {Function} success\n         @param {Function} failure\n         */\n        then: function(success, failure) {\n            return this.promise.then(success, failure);\n        },\n\n        /**\n         Aborts the Transition. Note you can also implicitly abort a transition\n         by initiating another transition while a previous one is underway.\n         */\n        abort: function() {\n            if (this.isAborted) { return this; }\n            log(this.router, this.sequence, this.targetName + ": transition was aborted");\n            this.isAborted = true;\n            this.isActive = false;\n            this.router.activeTransition = null;\n            return this;\n        },\n\n        /**\n         Retries a previously-aborted transition (making sure to abort the\n         transition if it\'s still active). Returns a new transition that\n         represents the new attempt to transition.\n         */\n        retry: function() {\n            this.abort();\n            var recogHandlers = this.router.recognizer.handlersFor(this.targetName),\n                handlerInfos  = generateHandlerInfosWithQueryParams(this.router, recogHandlers, this.queryParams),\n                newTransition = performTransition(this.router, handlerInfos, this.providedModelsArray, this.params, this.queryParams, this.data);\n\n            return newTransition;\n        },\n\n        /**\n         Sets the URL-changing method to be employed at the end of a\n         successful transition. By default, a new Transition will just\n         use `updateURL`, but passing \'replace\' to this method will\n         cause the URL to update using \'replaceWith\' instead. Omitting\n         a parameter will disable the URL change, allowing for transitions\n         that don\'t update the URL at completion (this is also used for\n         handleURL, since the URL has already changed before the\n         transition took place).\n\n         @param {String} method the type of URL-changing method to use\n         at the end of a transition. Accepted values are \'replace\',\n         falsy values, or any other non-falsy value (which is\n         interpreted as an updateURL transition).\n\n         @return {Transition} this transition\n         */\n        method: function(method) {\n            this.urlMethod = method;\n            return this;\n        },\n\n        /**\n         Fires an event on the current list of resolved/resolving\n         handlers within this transition. Useful for firing events\n         on route hierarchies that haven\'t fully been entered yet.\n\n         @param {Boolean} ignoreFailure the name of the event to fire\n         @param {String} name the name of the event to fire\n         */\n        trigger: function(ignoreFailure) {\n            var args = slice.call(arguments);\n            if (typeof ignoreFailure === \'boolean\') {\n                args.shift();\n            } else {\n                // Throw errors on unhandled trigger events by default\n                ignoreFailure = false;\n            }\n            trigger(this.router, this.handlerInfos.slice(0, this.resolveIndex + 1), ignoreFailure, args);\n        },\n\n        toString: function() {\n            return "Transition (sequence " + this.sequence + ")";\n        }\n    };\n\n    function Router() {\n        this.recognizer = new RouteRecognizer();\n    }\n\n    // TODO: separate into module?\n    Router.Transition = Transition;\n\n    __exports__.Router = Router;\n\n\n    /**\n     Promise reject reasons passed to promise rejection\n     handlers for failed transitions.\n     */\n    Router.UnrecognizedURLError = function(message) {\n        this.message = (message || "UnrecognizedURLError");\n        this.name = "UnrecognizedURLError";\n    };\n\n    Router.TransitionAborted = function(message) {\n        this.message = (message || "TransitionAborted");\n        this.name = "TransitionAborted";\n    };\n\n    function errorTransition(router, reason) {\n        return new Transition(router, RSVP.reject(reason));\n    }\n\n\n    Router.prototype = {\n        /**\n         The main entry point into the router. The API is essentially\n         the same as the `map` method in `route-recognizer`.\n\n         This method extracts the String handler at the last `.to()`\n         call and uses it as the name of the whole route.\n\n         @param {Function} callback\n         */\n        map: function(callback) {\n            this.recognizer.delegate = this.delegate;\n\n            this.recognizer.map(callback, function(recognizer, route) {\n                var lastHandler = route[route.length - 1].handler;\n                var args = [route, { as: lastHandler }];\n                recognizer.add.apply(recognizer, args);\n            });\n        },\n\n        hasRoute: function(route) {\n            return this.recognizer.hasRoute(route);\n        },\n\n        /**\n         Clears the current and target route handlers and triggers exit\n         on each of them starting at the leaf and traversing up through\n         its ancestors.\n         */\n        reset: function() {\n            eachHandler(this.currentHandlerInfos || [], function(handlerInfo) {\n                var handler = handlerInfo.handler;\n                if (handler.exit) {\n                    handler.exit();\n                }\n            });\n            this.currentHandlerInfos = null;\n            this.targetHandlerInfos = null;\n        },\n\n        activeTransition: null,\n\n        /**\n         var handler = handlerInfo.handler;\n         The entry point for handling a change to the URL (usually\n         via the back and forward button).\n\n         Returns an Array of handlers and the parameters associated\n         with those parameters.\n\n         @param {String} url a URL to process\n\n         @return {Array} an Array of `[handler, parameter]` tuples\n         */\n        handleURL: function(url) {\n            // Perform a URL-based transition, but don\'t change\n            // the URL afterward, since it already happened.\n            var args = slice.call(arguments);\n            if (url.charAt(0) !== \'/\') { args[0] = \'/\' + url; }\n            return doTransition(this, args).method(null);\n        },\n\n        /**\n         Hook point for updating the URL.\n\n         @param {String} url a URL to update to\n         */\n        updateURL: function() {\n            throw new Error("updateURL is not implemented");\n        },\n\n        /**\n         Hook point for replacing the current URL, i.e. with replaceState\n\n         By default this behaves the same as `updateURL`\n\n         @param {String} url a URL to update to\n         */\n        replaceURL: function(url) {\n            this.updateURL(url);\n        },\n\n        /**\n         Transition into the specified named route.\n\n         If necessary, trigger the exit callback on any handlers\n         that are no longer represented by the target route.\n\n         @param {String} name the name of the route\n         */\n        transitionTo: function(name) {\n            return doTransition(this, arguments);\n        },\n\n        intermediateTransitionTo: function(name) {\n            doTransition(this, arguments, true);\n        },\n\n        /**\n         Identical to `transitionTo` except that the current URL will be replaced\n         if possible.\n\n         This method is intended primarily for use with `replaceState`.\n\n         @param {String} name the name of the route\n         */\n        replaceWith: function(name) {\n            return doTransition(this, arguments).method(\'replace\');\n        },\n\n        /**\n         @private\n\n         This method takes a handler name and a list of contexts and returns\n         a serialized parameter hash suitable to pass to `recognizer.generate()`.\n\n         @param {String} handlerName\n         @param {Array[Object]} contexts\n         @return {Object} a serialized parameter hash\n         */\n\n        paramsForHandler: function(handlerName, contexts) {\n            var partitionedArgs = extractQueryParams(slice.call(arguments, 1));\n            return paramsForHandler(this, handlerName, partitionedArgs[0], partitionedArgs[1]);\n        },\n\n        /**\n         This method takes a handler name and returns a list of query params\n         that are valid to pass to the handler or its parents\n\n         @param {String} handlerName\n         @return {Array[String]} a list of query parameters\n         */\n        queryParamsForHandler: function (handlerName) {\n            return queryParamsForHandler(this, handlerName);\n        },\n\n        /**\n         Take a named route and context objects and generate a\n         URL.\n\n         @param {String} name the name of the route to generate\n         a URL for\n         @param {...Object} objects a list of objects to serialize\n\n         @return {String} a URL\n         */\n        generate: function(handlerName) {\n            var partitionedArgs = extractQueryParams(slice.call(arguments, 1)),\n                suppliedParams = partitionedArgs[0],\n                queryParams = partitionedArgs[1];\n\n            var params = paramsForHandler(this, handlerName, suppliedParams, queryParams),\n                validQueryParams = queryParamsForHandler(this, handlerName);\n\n            var missingParams = [];\n\n            for (var key in queryParams) {\n                if (queryParams.hasOwnProperty(key) && !~validQueryParams.indexOf(key)) {\n                    missingParams.push(key);\n                }\n            }\n\n            if (missingParams.length > 0) {\n                var err = \'You supplied the params \';\n                err += missingParams.map(function(param) {\n                    return \'"\' + param + "=" + queryParams[param] + \'"\';\n                }).join(\' and \');\n\n                err += \' which are not valid for the "\' + handlerName + \'" handler or its parents\';\n\n                throw new Error(err);\n            }\n\n            return this.recognizer.generate(handlerName, params);\n        },\n\n        isActive: function(handlerName) {\n            var partitionedArgs   = extractQueryParams(slice.call(arguments, 1)),\n                contexts          = partitionedArgs[0],\n                queryParams       = partitionedArgs[1],\n                activeQueryParams  = {},\n                effectiveQueryParams = {};\n\n            var targetHandlerInfos = this.targetHandlerInfos,\n                found = false, names, object, handlerInfo, handlerObj;\n\n            if (!targetHandlerInfos) { return false; }\n\n            var recogHandlers = this.recognizer.handlersFor(targetHandlerInfos[targetHandlerInfos.length - 1].name);\n            for (var i=targetHandlerInfos.length-1; i>=0; i--) {\n                handlerInfo = targetHandlerInfos[i];\n                if (handlerInfo.name === handlerName) { found = true; }\n\n                if (found) {\n                    var recogHandler = recogHandlers[i];\n\n                    merge(activeQueryParams, handlerInfo.queryParams);\n                    if (queryParams !== false) {\n                        merge(effectiveQueryParams, handlerInfo.queryParams);\n                        mergeSomeKeys(effectiveQueryParams, queryParams, recogHandler.queryParams);\n                    }\n\n                    if (handlerInfo.isDynamic && contexts.length > 0) {\n                        object = contexts.pop();\n\n                        if (isParam(object)) {\n                            var name = recogHandler.names[0];\n                            if ("" + object !== this.currentParams[name]) { return false; }\n                        } else if (handlerInfo.context !== object) {\n                            return false;\n                        }\n                    }\n                }\n            }\n\n\n            return contexts.length === 0 && found && queryParamsEqual(activeQueryParams, effectiveQueryParams);\n        },\n\n        trigger: function(name) {\n            var args = slice.call(arguments);\n            trigger(this, this.currentHandlerInfos, false, args);\n        },\n\n        /**\n         Hook point for logging transition status updates.\n\n         @param {String} message The message to log.\n         */\n        log: null\n    };\n\n    /**\n     @private\n\n     Used internally for both URL and named transition to determine\n     a shared pivot parent route and other data necessary to perform\n     a transition.\n     */\n    function getMatchPoint(router, handlers, objects, inputParams, queryParams) {\n\n        var matchPoint = handlers.length,\n            providedModels = {}, i,\n            currentHandlerInfos = router.currentHandlerInfos || [],\n            params = {},\n            oldParams = router.currentParams || {},\n            activeTransition = router.activeTransition,\n            handlerParams = {},\n            obj;\n\n        objects = slice.call(objects);\n        merge(params, inputParams);\n\n        for (i = handlers.length - 1; i >= 0; i--) {\n            var handlerObj = handlers[i],\n                handlerName = handlerObj.handler,\n                oldHandlerInfo = currentHandlerInfos[i],\n                hasChanged = false;\n\n            // Check if handler names have changed.\n            if (!oldHandlerInfo || oldHandlerInfo.name !== handlerObj.handler) { hasChanged = true; }\n\n            if (handlerObj.isDynamic) {\n                // URL transition.\n\n                if (obj = getMatchPointObject(objects, handlerName, activeTransition, true, params)) {\n                    hasChanged = true;\n                    providedModels[handlerName] = obj;\n                } else {\n                    handlerParams[handlerName] = {};\n                    for (var prop in handlerObj.params) {\n                        if (!handlerObj.params.hasOwnProperty(prop)) { continue; }\n                        var newParam = handlerObj.params[prop];\n                        if (oldParams[prop] !== newParam) { hasChanged = true; }\n                        handlerParams[handlerName][prop] = params[prop] = newParam;\n                    }\n                }\n            } else if (handlerObj.hasOwnProperty(\'names\')) {\n                // Named transition.\n\n                if (objects.length) { hasChanged = true; }\n\n                if (obj = getMatchPointObject(objects, handlerName, activeTransition, handlerObj.names[0], params)) {\n                    providedModels[handlerName] = obj;\n                } else {\n                    var names = handlerObj.names;\n                    handlerParams[handlerName] = {};\n                    for (var j = 0, len = names.length; j < len; ++j) {\n                        var name = names[j];\n                        handlerParams[handlerName][name] = params[name] = params[name] || oldParams[name];\n                    }\n                }\n            }\n\n            // If there is an old handler, see if query params are the same. If there isn\'t an old handler,\n            // hasChanged will already be true here\n            if(oldHandlerInfo && !queryParamsEqual(oldHandlerInfo.queryParams, handlerObj.queryParams)) {\n                hasChanged = true;\n            }\n\n            if (hasChanged) { matchPoint = i; }\n        }\n\n        if (objects.length > 0) {\n            throw new Error("More context objects were passed than there are dynamic segments for the route: " + handlers[handlers.length - 1].handler);\n        }\n\n        var pivotHandlerInfo = currentHandlerInfos[matchPoint - 1],\n            pivotHandler = pivotHandlerInfo && pivotHandlerInfo.handler;\n\n        return { matchPoint: matchPoint, providedModels: providedModels, params: params, handlerParams: handlerParams, pivotHandler: pivotHandler };\n    }\n\n    function getMatchPointObject(objects, handlerName, activeTransition, paramName, params) {\n\n        if (objects.length && paramName) {\n\n            var object = objects.pop();\n\n            // If provided object is string or number, treat as param.\n            if (isParam(object)) {\n                params[paramName] = object.toString();\n            } else {\n                return object;\n            }\n        } else if (activeTransition) {\n            // Use model from previous transition attempt, preferably the resolved one.\n            return activeTransition.resolvedModels[handlerName] ||\n                (paramName && activeTransition.providedModels[handlerName]);\n        }\n    }\n\n    function isParam(object) {\n        return (typeof object === "string" || object instanceof String || typeof object === "number" || object instanceof Number);\n    }\n\n\n\n    /**\n     @private\n\n     This method takes a handler name and returns a list of query params\n     that are valid to pass to the handler or its parents\n\n     @param {Router} router\n     @param {String} handlerName\n     @return {Array[String]} a list of query parameters\n     */\n    function queryParamsForHandler(router, handlerName) {\n        var handlers = router.recognizer.handlersFor(handlerName),\n            queryParams = [];\n\n        for (var i = 0; i < handlers.length; i++) {\n            queryParams.push.apply(queryParams, handlers[i].queryParams || []);\n        }\n\n        return queryParams;\n    }\n    /**\n     @private\n\n     This method takes a handler name and a list of contexts and returns\n     a serialized parameter hash suitable to pass to `recognizer.generate()`.\n\n     @param {Router} router\n     @param {String} handlerName\n     @param {Array[Object]} objects\n     @return {Object} a serialized parameter hash\n     */\n    function paramsForHandler(router, handlerName, objects, queryParams) {\n\n        var handlers = router.recognizer.handlersFor(handlerName),\n            params = {},\n            handlerInfos = generateHandlerInfosWithQueryParams(router, handlers, queryParams),\n            matchPoint = getMatchPoint(router, handlerInfos, objects).matchPoint,\n            mergedQueryParams = {},\n            object, handlerObj, handler, names, i;\n\n        params.queryParams = {};\n\n        for (i=0; i<handlers.length; i++) {\n            handlerObj = handlers[i];\n            handler = router.getHandler(handlerObj.handler);\n            names = handlerObj.names;\n\n            // If it\'s a dynamic segment\n            if (names.length) {\n                // If we have objects, use them\n                if (i >= matchPoint) {\n                    object = objects.shift();\n                    // Otherwise use existing context\n                } else {\n                    object = handler.context;\n                }\n\n                // Serialize to generate params\n                merge(params, serialize(handler, object, names));\n            }\n            if (queryParams !== false) {\n                mergeSomeKeys(params.queryParams, router.currentQueryParams, handlerObj.queryParams);\n                mergeSomeKeys(params.queryParams, queryParams, handlerObj.queryParams);\n            }\n        }\n\n        if (queryParamsEqual(params.queryParams, {})) { delete params.queryParams; }\n        return params;\n    }\n\n    function merge(hash, other) {\n        for (var prop in other) {\n            if (other.hasOwnProperty(prop)) { hash[prop] = other[prop]; }\n        }\n    }\n\n    function mergeSomeKeys(hash, other, keys) {\n        if (!other || !keys) { return; }\n        for(var i = 0; i < keys.length; i++) {\n            var key = keys[i], value;\n            if(other.hasOwnProperty(key)) {\n                value = other[key];\n                if(value === null || value === false || typeof value === "undefined") {\n                    delete hash[key];\n                } else {\n                    hash[key] = other[key];\n                }\n            }\n        }\n    }\n\n    /**\n     @private\n     */\n\n    function generateHandlerInfosWithQueryParams(router, handlers, queryParams) {\n        var handlerInfos = [];\n\n        for (var i = 0; i < handlers.length; i++) {\n            var handler = handlers[i],\n                handlerInfo = { handler: handler.handler, names: handler.names, context: handler.context, isDynamic: handler.isDynamic },\n                activeQueryParams = {};\n\n            if (queryParams !== false) {\n                mergeSomeKeys(activeQueryParams, router.currentQueryParams, handler.queryParams);\n                mergeSomeKeys(activeQueryParams, queryParams, handler.queryParams);\n            }\n\n            if (handler.queryParams && handler.queryParams.length > 0) {\n                handlerInfo.queryParams = activeQueryParams;\n            }\n\n            handlerInfos.push(handlerInfo);\n        }\n\n        return handlerInfos;\n    }\n\n    /**\n     @private\n     */\n    function createQueryParamTransition(router, queryParams, isIntermediate) {\n        var currentHandlers = router.currentHandlerInfos,\n            currentHandler = currentHandlers[currentHandlers.length - 1],\n            name = currentHandler.name;\n\n        log(router, "Attempting query param transition");\n\n        return createNamedTransition(router, [name, queryParams], isIntermediate);\n    }\n\n    /**\n     @private\n     */\n    function createNamedTransition(router, args, isIntermediate) {\n        var partitionedArgs     = extractQueryParams(args),\n            pureArgs              = partitionedArgs[0],\n            queryParams           = partitionedArgs[1],\n            handlers              = router.recognizer.handlersFor(pureArgs[0]),\n            handlerInfos          = generateHandlerInfosWithQueryParams(router, handlers, queryParams);\n\n\n        log(router, "Attempting transition to " + pureArgs[0]);\n\n        return performTransition(router,\n            handlerInfos,\n            slice.call(pureArgs, 1),\n            router.currentParams,\n            queryParams,\n            null,\n            isIntermediate);\n    }\n\n    /**\n     @private\n     */\n    function createURLTransition(router, url, isIntermediate) {\n        var results = router.recognizer.recognize(url),\n            currentHandlerInfos = router.currentHandlerInfos,\n            queryParams = {},\n            i, len;\n\n        log(router, "Attempting URL transition to " + url);\n\n        if (results) {\n            // Make sure this route is actually accessible by URL.\n            for (i = 0, len = results.length; i < len; ++i) {\n\n                if (router.getHandler(results[i].handler).inaccessibleByURL) {\n                    results = null;\n                    break;\n                }\n            }\n        }\n\n        if (!results) {\n            return errorTransition(router, new Router.UnrecognizedURLError(url));\n        }\n\n        for(i = 0, len = results.length; i < len; i++) {\n            merge(queryParams, results[i].queryParams);\n        }\n\n        return performTransition(router, results, [], {}, queryParams, null, isIntermediate);\n    }\n\n\n    /**\n     @private\n\n     Takes an Array of `HandlerInfo`s, figures out which ones are\n     exiting, entering, or changing contexts, and calls the\n     proper handler hooks.\n\n     For example, consider the following tree of handlers. Each handler is\n     followed by the URL segment it handles.\n\n     ```\n     |~index ("/")\n     | |~posts ("/posts")\n     | | |-showPost ("/:id")\n     | | |-newPost ("/new")\n     | | |-editPost ("/edit")\n     | |~about ("/about/:id")\n     ```\n\n     Consider the following transitions:\n\n     1. A URL transition to `/posts/1`.\n     1. Triggers the `*model` callbacks on the\n     `index`, `posts`, and `showPost` handlers\n     2. Triggers the `enter` callback on the same\n     3. Triggers the `setup` callback on the same\n     2. A direct transition to `newPost`\n     1. Triggers the `exit` callback on `showPost`\n     2. Triggers the `enter` callback on `newPost`\n     3. Triggers the `setup` callback on `newPost`\n     3. A direct transition to `about` with a specified\n     context object\n     1. Triggers the `exit` callback on `newPost`\n     and `posts`\n     2. Triggers the `serialize` callback on `about`\n     3. Triggers the `enter` callback on `about`\n     4. Triggers the `setup` callback on `about`\n\n     @param {Transition} transition\n     @param {Array[HandlerInfo]} handlerInfos\n     */\n    function setupContexts(transition, handlerInfos) {\n        var router = transition.router,\n            partition = partitionHandlers(router.currentHandlerInfos || [], handlerInfos);\n\n        router.targetHandlerInfos = handlerInfos;\n\n        eachHandler(partition.exited, function(handlerInfo) {\n            var handler = handlerInfo.handler;\n            delete handler.context;\n            if (handler.exit) { handler.exit(); }\n        });\n\n        var currentHandlerInfos = partition.unchanged.slice();\n        router.currentHandlerInfos = currentHandlerInfos;\n\n        eachHandler(partition.updatedContext, function(handlerInfo) {\n            handlerEnteredOrUpdated(transition, currentHandlerInfos, handlerInfo, false);\n        });\n\n        eachHandler(partition.entered, function(handlerInfo) {\n            handlerEnteredOrUpdated(transition, currentHandlerInfos, handlerInfo, true);\n        });\n    }\n\n    /**\n     @private\n\n     Helper method used by setupContexts. Handles errors or redirects\n     that may happen in enter/setup.\n     */\n    function handlerEnteredOrUpdated(transition, currentHandlerInfos, handlerInfo, enter) {\n        var handler = handlerInfo.handler,\n            context = handlerInfo.context;\n\n        try {\n            if (enter && handler.enter) { handler.enter(); }\n            checkAbort(transition);\n\n            setContext(handler, context);\n            setQueryParams(handler, handlerInfo.queryParams);\n\n            if (handler.setup) { handler.setup(context, handlerInfo.queryParams); }\n            checkAbort(transition);\n        } catch(e) {\n            if (!(e instanceof Router.TransitionAborted)) {\n                // Trigger the `error` event starting from this failed handler.\n                transition.trigger(true, \'error\', e, transition, handler);\n            }\n\n            // Propagate the error so that the transition promise will reject.\n            throw e;\n        }\n\n        currentHandlerInfos.push(handlerInfo);\n    }\n\n\n    /**\n     @private\n\n     Iterates over an array of `HandlerInfo`s, passing the handler\n     and context into the callback.\n\n     @param {Array[HandlerInfo]} handlerInfos\n     @param {Function(Object, Object)} callback\n     */\n    function eachHandler(handlerInfos, callback) {\n        for (var i=0, l=handlerInfos.length; i<l; i++) {\n            callback(handlerInfos[i]);\n        }\n    }\n\n    /**\n     @private\n\n     determines if two queryparam objects are the same or not\n     **/\n    function queryParamsEqual(a, b) {\n        a = a || {};\n        b = b || {};\n        var checkedKeys = [], key;\n        for(key in a) {\n            if (!a.hasOwnProperty(key)) { continue; }\n            if(b[key] !== a[key]) { return false; }\n            checkedKeys.push(key);\n        }\n        for(key in b) {\n            if (!b.hasOwnProperty(key)) { continue; }\n            if (~checkedKeys.indexOf(key)) { continue; }\n            // b has a key not in a\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     @private\n\n     This function is called when transitioning from one URL to\n     another to determine which handlers are no longer active,\n     which handlers are newly active, and which handlers remain\n     active but have their context changed.\n\n     Take a list of old handlers and new handlers and partition\n     them into four buckets:\n\n     * unchanged: the handler was active in both the old and\n     new URL, and its context remains the same\n     * updated context: the handler was active in both the\n     old and new URL, but its context changed. The handler\'s\n     `setup` method, if any, will be called with the new\n     context.\n     * exited: the handler was active in the old URL, but is\n     no longer active.\n     * entered: the handler was not active in the old URL, but\n     is now active.\n\n     The PartitionedHandlers structure has four fields:\n\n     * `updatedContext`: a list of `HandlerInfo` objects that\n     represent handlers that remain active but have a changed\n     context\n     * `entered`: a list of `HandlerInfo` objects that represent\n     handlers that are newly active\n     * `exited`: a list of `HandlerInfo` objects that are no\n     longer active.\n     * `unchanged`: a list of `HanderInfo` objects that remain active.\n\n     @param {Array[HandlerInfo]} oldHandlers a list of the handler\n     information for the previous URL (or `[]` if this is the\n     first handled transition)\n     @param {Array[HandlerInfo]} newHandlers a list of the handler\n     information for the new URL\n\n     @return {Partition}\n     */\n    function partitionHandlers(oldHandlers, newHandlers) {\n        var handlers = {\n            updatedContext: [],\n            exited: [],\n            entered: [],\n            unchanged: []\n        };\n\n        var handlerChanged, contextChanged, queryParamsChanged, i, l;\n\n        for (i=0, l=newHandlers.length; i<l; i++) {\n            var oldHandler = oldHandlers[i], newHandler = newHandlers[i];\n\n            if (!oldHandler || oldHandler.handler !== newHandler.handler) {\n                handlerChanged = true;\n            } else if (!queryParamsEqual(oldHandler.queryParams, newHandler.queryParams)) {\n                queryParamsChanged = true;\n            }\n\n            if (handlerChanged) {\n                handlers.entered.push(newHandler);\n                if (oldHandler) { handlers.exited.unshift(oldHandler); }\n            } else if (contextChanged || oldHandler.context !== newHandler.context || queryParamsChanged) {\n                contextChanged = true;\n                handlers.updatedContext.push(newHandler);\n            } else {\n                handlers.unchanged.push(oldHandler);\n            }\n        }\n\n        for (i=newHandlers.length, l=oldHandlers.length; i<l; i++) {\n            handlers.exited.unshift(oldHandlers[i]);\n        }\n\n        return handlers;\n    }\n\n    function trigger(router, handlerInfos, ignoreFailure, args) {\n        if (router.triggerEvent) {\n            router.triggerEvent(handlerInfos, ignoreFailure, args);\n            return;\n        }\n\n        var name = args.shift();\n\n        if (!handlerInfos) {\n            if (ignoreFailure) { return; }\n            throw new Error("Could not trigger event \'" + name + "\'. There are no active handlers");\n        }\n\n        var eventWasHandled = false;\n\n        for (var i=handlerInfos.length-1; i>=0; i--) {\n            var handlerInfo = handlerInfos[i],\n                handler = handlerInfo.handler;\n\n            if (handler.events && handler.events[name]) {\n                if (handler.events[name].apply(handler, args) === true) {\n                    eventWasHandled = true;\n                } else {\n                    return;\n                }\n            }\n        }\n\n        if (!eventWasHandled && !ignoreFailure) {\n            throw new Error("Nothing handled the event \'" + name + "\'.");\n        }\n    }\n\n    function setContext(handler, context) {\n        handler.context = context;\n        if (handler.contextDidChange) { handler.contextDidChange(); }\n    }\n\n    function setQueryParams(handler, queryParams) {\n        handler.queryParams = queryParams;\n        if (handler.queryParamsDidChange) { handler.queryParamsDidChange(); }\n    }\n\n\n    /**\n     @private\n\n     Extracts query params from the end of an array\n     **/\n\n    function extractQueryParams(array) {\n        var len = (array && array.length), head, queryParams;\n\n        if(len && len > 0 && array[len - 1] && array[len - 1].hasOwnProperty(\'queryParams\')) {\n            queryParams = array[len - 1].queryParams;\n            head = slice.call(array, 0, len - 1);\n            return [head, queryParams];\n        } else {\n            return [array, null];\n        }\n    }\n\n    function performIntermediateTransition(router, recogHandlers, matchPointResults) {\n\n        var handlerInfos = generateHandlerInfos(router, recogHandlers);\n        for (var i = 0; i < handlerInfos.length; ++i) {\n            var handlerInfo = handlerInfos[i];\n            handlerInfo.context = matchPointResults.providedModels[handlerInfo.name];\n        }\n\n        var stubbedTransition = {\n            router: router,\n            isAborted: false\n        };\n\n        setupContexts(stubbedTransition, handlerInfos);\n    }\n\n    /**\n     @private\n\n     Creates, begins, and returns a Transition.\n     */\n    function performTransition(router, recogHandlers, providedModelsArray, params, queryParams, data, isIntermediate) {\n\n        var matchPointResults = getMatchPoint(router, recogHandlers, providedModelsArray, params, queryParams),\n            targetName = recogHandlers[recogHandlers.length - 1].handler,\n            wasTransitioning = false,\n            currentHandlerInfos = router.currentHandlerInfos;\n\n        if (isIntermediate) {\n            return performIntermediateTransition(router, recogHandlers, matchPointResults);\n        }\n\n        // Check if there\'s already a transition underway.\n        if (router.activeTransition) {\n            if (transitionsIdentical(router.activeTransition, targetName, providedModelsArray, queryParams)) {\n                return router.activeTransition;\n            }\n            router.activeTransition.abort();\n            wasTransitioning = true;\n        }\n\n        var deferred = RSVP.defer(),\n            transition = new Transition(router, deferred.promise);\n\n        transition.targetName = targetName;\n        transition.providedModels = matchPointResults.providedModels;\n        transition.providedModelsArray = providedModelsArray;\n        transition.params = matchPointResults.params;\n        transition.data = data || {};\n        transition.queryParams = queryParams;\n        transition.pivotHandler = matchPointResults.pivotHandler;\n        router.activeTransition = transition;\n\n        var handlerInfos = generateHandlerInfos(router, recogHandlers);\n        transition.handlerInfos = handlerInfos;\n\n        // Fire \'willTransition\' event on current handlers, but don\'t fire it\n        // if a transition was already underway.\n        if (!wasTransitioning) {\n            trigger(router, currentHandlerInfos, true, [\'willTransition\', transition]);\n        }\n\n        log(router, transition.sequence, "Beginning validation for transition to " + transition.targetName);\n        validateEntry(transition, matchPointResults.matchPoint, matchPointResults.handlerParams)\n            .then(transitionSuccess, transitionFailure);\n\n        return transition;\n\n        function transitionSuccess() {\n            checkAbort(transition);\n\n            try {\n                finalizeTransition(transition, handlerInfos);\n\n                // currentHandlerInfos was updated in finalizeTransition\n                trigger(router, router.currentHandlerInfos, true, [\'didTransition\']);\n\n                if (router.didTransition) {\n                    router.didTransition(handlerInfos);\n                }\n\n                log(router, transition.sequence, "TRANSITION COMPLETE.");\n\n                // Resolve with the final handler.\n                transition.isActive = false;\n                deferred.resolve(handlerInfos[handlerInfos.length - 1].handler);\n            } catch(e) {\n                deferred.reject(e);\n            }\n\n            // Don\'t nullify if another transition is underway (meaning\n            // there was a transition initiated with enter/setup).\n            if (!transition.isAborted) {\n                router.activeTransition = null;\n            }\n        }\n\n        function transitionFailure(reason) {\n            deferred.reject(reason);\n        }\n    }\n\n    /**\n     @private\n\n     Accepts handlers in Recognizer format, either returned from\n     recognize() or handlersFor(), and returns unified\n     `HandlerInfo`s.\n     */\n    function generateHandlerInfos(router, recogHandlers) {\n        var handlerInfos = [];\n        for (var i = 0, len = recogHandlers.length; i < len; ++i) {\n            var handlerObj = recogHandlers[i],\n                isDynamic = handlerObj.isDynamic || (handlerObj.names && handlerObj.names.length);\n\n            var handlerInfo = {\n                isDynamic: !!isDynamic,\n                name: handlerObj.handler,\n                handler: router.getHandler(handlerObj.handler)\n            };\n            if(handlerObj.queryParams) {\n                handlerInfo.queryParams = handlerObj.queryParams;\n            }\n            handlerInfos.push(handlerInfo);\n        }\n        return handlerInfos;\n    }\n\n    /**\n     @private\n     */\n    function transitionsIdentical(oldTransition, targetName, providedModelsArray, queryParams) {\n\n        if (oldTransition.targetName !== targetName) { return false; }\n\n        var oldModels = oldTransition.providedModelsArray;\n        if (oldModels.length !== providedModelsArray.length) { return false; }\n\n        for (var i = 0, len = oldModels.length; i < len; ++i) {\n            if (oldModels[i] !== providedModelsArray[i]) { return false; }\n        }\n\n        if(!queryParamsEqual(oldTransition.queryParams, queryParams)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     @private\n\n     Updates the URL (if necessary) and calls `setupContexts`\n     to update the router\'s array of `currentHandlerInfos`.\n     */\n    function finalizeTransition(transition, handlerInfos) {\n\n        log(transition.router, transition.sequence, "Validation succeeded, finalizing transition;");\n\n        var router = transition.router,\n            seq = transition.sequence,\n            handlerName = handlerInfos[handlerInfos.length - 1].name,\n            urlMethod = transition.urlMethod,\n            i;\n\n        // Collect params for URL.\n        var objects = [], providedModels = transition.providedModelsArray.slice();\n        for (i = handlerInfos.length - 1; i>=0; --i) {\n            var handlerInfo = handlerInfos[i];\n            if (handlerInfo.isDynamic) {\n                var providedModel = providedModels.pop();\n                objects.unshift(isParam(providedModel) ? providedModel.toString() : handlerInfo.context);\n            }\n\n            if (handlerInfo.handler.inaccessibleByURL) {\n                urlMethod = null;\n            }\n        }\n\n        var newQueryParams = {};\n        for (i = handlerInfos.length - 1; i>=0; --i) {\n            merge(newQueryParams, handlerInfos[i].queryParams);\n        }\n        router.currentQueryParams = newQueryParams;\n\n\n        var params = paramsForHandler(router, handlerName, objects, transition.queryParams);\n\n        router.currentParams = params;\n\n        if (urlMethod) {\n            var url = router.recognizer.generate(handlerName, params);\n\n            if (urlMethod === \'replace\') {\n                router.replaceURL(url);\n            } else {\n                // Assume everything else is just a URL update for now.\n                router.updateURL(url);\n            }\n        }\n\n        setupContexts(transition, handlerInfos);\n    }\n\n    /**\n     @private\n\n     Internal function used to construct the chain of promises used\n     to validate a transition. Wraps calls to `beforeModel`, `model`,\n     and `afterModel` in promises, and checks for redirects/aborts\n     between each.\n     */\n    function validateEntry(transition, matchPoint, handlerParams) {\n\n        var handlerInfos = transition.handlerInfos,\n            index = transition.resolveIndex;\n\n        if (index === handlerInfos.length) {\n            // No more contexts to resolve.\n            return RSVP.resolve(transition.resolvedModels);\n        }\n\n        var router = transition.router,\n            handlerInfo = handlerInfos[index],\n            handler = handlerInfo.handler,\n            handlerName = handlerInfo.name,\n            seq = transition.sequence;\n\n        if (index < matchPoint) {\n            log(router, seq, handlerName + ": using context from already-active handler");\n\n            // We\'re before the match point, so don\'t run any hooks,\n            // just use the already resolved context from the handler.\n            transition.resolvedModels[handlerInfo.name] =\n                transition.providedModels[handlerInfo.name] ||\n                handlerInfo.handler.context;\n            return proceed();\n        }\n\n        transition.trigger(true, \'willResolveModel\', transition, handler);\n\n        return RSVP.resolve().then(handleAbort)\n            .then(beforeModel)\n            .then(handleAbort)\n            .then(model)\n            .then(handleAbort)\n            .then(afterModel)\n            .then(handleAbort)\n            .then(null, handleError)\n            .then(proceed);\n\n        function handleAbort(result) {\n            if (transition.isAborted) {\n                log(transition.router, transition.sequence, "detected abort.");\n                return RSVP.reject(new Router.TransitionAborted());\n            }\n\n            return result;\n        }\n\n        function handleError(reason) {\n            if (reason instanceof Router.TransitionAborted || transition.isAborted) {\n                // if the transition was aborted and *no additional* error was thrown,\n                // reject with the Router.TransitionAborted instance\n                return RSVP.reject(reason);\n            }\n\n            // otherwise, we\'re here because of a different error\n            transition.abort();\n\n            log(router, seq, handlerName + ": handling error: " + reason);\n\n            // An error was thrown / promise rejected, so fire an\n            // `error` event from this handler info up to root.\n            transition.trigger(true, \'error\', reason, transition, handlerInfo.handler);\n\n            // Propagate the original error.\n            return RSVP.reject(reason);\n        }\n\n        function beforeModel() {\n\n            log(router, seq, handlerName + ": calling beforeModel hook");\n\n            var args;\n\n            if (handlerInfo.queryParams) {\n                args = [handlerInfo.queryParams, transition];\n            } else {\n                args = [transition];\n            }\n\n            var p = handler.beforeModel && handler.beforeModel.apply(handler, args);\n            return (p instanceof Transition) ? null : p;\n        }\n\n        function model() {\n            log(router, seq, handlerName + ": resolving model");\n            var p = getModel(handlerInfo, transition, handlerParams[handlerName], index >= matchPoint);\n            return (p instanceof Transition) ? null : p;\n        }\n\n        function afterModel(context) {\n\n            log(router, seq, handlerName + ": calling afterModel hook");\n\n            // Pass the context and resolved parent contexts to afterModel, but we don\'t\n            // want to use the value returned from `afterModel` in any way, but rather\n            // always resolve with the original `context` object.\n\n            transition.resolvedModels[handlerInfo.name] = context;\n\n            var args;\n\n            if (handlerInfo.queryParams) {\n                args = [context, handlerInfo.queryParams, transition];\n            } else {\n                args = [context, transition];\n            }\n\n            var p = handler.afterModel && handler.afterModel.apply(handler, args);\n            return (p instanceof Transition) ? null : p;\n        }\n\n        function proceed() {\n            log(router, seq, handlerName + ": validation succeeded, proceeding");\n\n            handlerInfo.context = transition.resolvedModels[handlerInfo.name];\n            transition.resolveIndex++;\n            return validateEntry(transition, matchPoint, handlerParams);\n        }\n    }\n\n    /**\n     @private\n\n     Throws a TransitionAborted if the provided transition has been aborted.\n     */\n    function checkAbort(transition) {\n        if (transition.isAborted) {\n            log(transition.router, transition.sequence, "detected abort.");\n            throw new Router.TransitionAborted();\n        }\n    }\n\n    /**\n     @private\n\n     Encapsulates the logic for whether to call `model` on a route,\n     or use one of the models provided to `transitionTo`.\n     */\n    function getModel(handlerInfo, transition, handlerParams, needsUpdate) {\n        var handler = handlerInfo.handler,\n            handlerName = handlerInfo.name, args;\n\n        if (!needsUpdate && handler.hasOwnProperty(\'context\')) {\n            return handler.context;\n        }\n\n        if (transition.providedModels.hasOwnProperty(handlerName)) {\n            var providedModel = transition.providedModels[handlerName];\n            return typeof providedModel === \'function\' ? providedModel() : providedModel;\n        }\n\n        if (handlerInfo.queryParams) {\n            args = [handlerParams || {}, handlerInfo.queryParams, transition];\n        } else {\n            args = [handlerParams || {}, transition, handlerInfo.queryParams];\n        }\n\n        return handler.model && handler.model.apply(handler, args);\n    }\n\n    /**\n     @private\n     */\n    function log(router, sequence, msg) {\n\n        if (!router.log) { return; }\n\n        if (arguments.length === 3) {\n            router.log("Transition #" + sequence + ": " + msg);\n        } else {\n            msg = sequence;\n            router.log(msg);\n        }\n    }\n\n    /**\n     @private\n\n     Begins and returns a Transition based on the provided\n     arguments. Accepts arguments in the form of both URL\n     transitions and named transitions.\n\n     @param {Router} router\n     @param {Array[Object]} args arguments passed to transitionTo,\n     replaceWith, or handleURL\n     */\n    function doTransition(router, args, isIntermediate) {\n        // Normalize blank transitions to root URL transitions.\n        var name = args[0] || \'/\';\n\n        if(args.length === 1 && args[0].hasOwnProperty(\'queryParams\')) {\n            return createQueryParamTransition(router, args[0], isIntermediate);\n        } else if (name.charAt(0) === \'/\') {\n            return createURLTransition(router, name, isIntermediate);\n        } else {\n            return createNamedTransition(router, slice.call(args), isIntermediate);\n        }\n    }\n\n    /**\n     @private\n\n     Serializes a handler using its custom `serialize` method or\n     by a default that looks up the expected property name from\n     the dynamic segment.\n\n     @param {Object} handler a router handler\n     @param {Object} model the model to be serialized for this handler\n     @param {Array[Object]} names the names array attached to an\n     handler object returned from router.recognizer.handlersFor()\n     */\n    function serialize(handler, model, names) {\n\n        var object = {};\n        if (isParam(model)) {\n            object[names[0]] = model;\n            return object;\n        }\n\n        // Use custom serialize if it exists.\n        if (handler.serialize) {\n            return handler.serialize(model, names);\n        }\n\n        if (names.length !== 1) { return; }\n\n        var name = names[0];\n\n        if (/_id$/.test(name)) {\n            object[name] = model.id;\n        } else {\n            object[name] = model;\n        }\n        return object;\n    }\n})(window, window.RouteRecognizer, window.RSVP);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/router.js/router-amd.js\n ** module id = 174\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./lib/router.js/router-amd.js?');
},175:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(161), RootInstanceProvider = __webpack_require__(159), ReactMount = __webpack_require__(69), React = __webpack_require__(3); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Network = (function () {\n    function Network(options) {\n        _classCallCheck(this, Network);\n    }\n\n    _createClass(Network, [{\n        key: "init",\n        value: function init() {\n            var self = this;\n            var promise = new Promise(function (resolve, reject) {\n\n                console.log(">>> network.init()");\n\n                if (true) {\n                    resolve(self);\n                } else {\n                    reject(new Error("Error while network.init"));\n                }\n            });\n\n            return promise;\n        }\n    }]);\n\n    return Network;\n})();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    var network = new Network();\n    return network;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//this.model = options.model;\n//this.template = options.template;\n\n/* REACT HOT LOADER */ }).call(this); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(169), foundReactClasses = false; if (makeExportsHot(module, __webpack_require__(3))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "index.js" + ": " + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/services/network/index.js\n ** module id = 175\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./src/services/network/index.js?')}});